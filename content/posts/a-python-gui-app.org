---
title: "A Python Tkinter GUI App That Won't Make You Puke Blood (Part 1)"
alternateTitle: "Buliding a Pure Python / Tkinter application for downloading from FormSG (Part 1)"
image: "img/post-a-python-gui-app-title.jpg"
imageCredit: "Jon Tyson (https://unsplash.com/photos/Q_GnkCF1PrE)"
date: 2020-06-21
draft: false
---

If you are looking to build simple GUI application in Python Tkinter and distribute
  it to your friends, but are having problems navigating the greek
  documentation, look no further, read on for how I did it.

* TL;DR
I automated my interaction with a website, but needed to pass on my duty to
  non-techincal colleague, so I built a GUI application in Tkinter.

When building an application in Tkinter:
  - If you have not used Tkinter before, refer to the [[https://docs.python.org/3/library/tkinter.html#tkinter-life-preserver][Tkinter Life Preserver]] on
    Python's official documentation for a good overview on how to approach using
    Tkinter. It provides valuable guidance on translating pure Tcl/Tk method
    calls into the corresponding Tkinter calls in Python.
  - When, refer to [[https://tkdocs.com/tutorial/index.html][TkDocs]] (which is clear, covers many topics, and has good code
    samples)
  - Next, refer to [[http://effbot.org/tkinterbook/][effbot.org]] (which covers certain things not covered by
    TkDocs)
  - And finally, if the feature is not covered by either of the above, refer to
    [[https://www.tcl.tk/man/tcl8.7/TclCmd/contents.htm][Tcl]]/[[https://www.tcl.tk/man/tcl8.7/TkCmd/contents.htm][Tk]] documentation for the official specification, and make educated guess
    on what Python method / arguments to pass.

* Background
As part of Covid-19 response, I was involved in collecting information via a
  government website called FormSG. I was administering over 20 forms, with
  multiple versions of each form, and need to do daily reporting.

Naturally, I automated the task (initially using TagUI, but very quickly
  switching to the trusty Selenium).

Eventually, there was additional manpower (or womanpower to be accurate) to
  share my daily load of running the scripts. So I needed to build something
  that is more user-friendly. (Note: I initially used batch files, and taught my
  colleague how to the batch files.)

* Tkinter Background And Resources
Tkinter is part of Python's standard library, providing access to the Tcl/Tk
  graphical user interface toolkit. And since Python's standard library has
  always been of very high standard, with well-thought out inclusion / exclusion
  and implementation, it must say something that Tcl/Tk is the chosen GUI
  framework.

Unfortunately, documentation for Tcl/Tk (the underlying framework) and Tkinter
  (Python's wrapper to the framework) are hard to follow at times.

As such, the next following paragraph would be the most valuable one you will
  read in this article:
  - If you have not used Tkinter before, refer to the [[https://docs.python.org/3/library/tkinter.html#tkinter-life-preserver][Tkinter Life Preserver]] on
    Python's official documentation for a good overview on how to approach using
    Tkinter. It provides valuable guidance on translating pure Tcl/Tk method
    calls into the corresponding Tkinter calls in Python.
  - First refer to [[https://tkdocs.com/tutorial/index.html][TkDocs]] (which is clear, covers many topics, and has good code
    samples)
  - Next, refer to [[http://effbot.org/tkinterbook/][effbot.org]] (which covers certain things not covered by
    TkDocs)
  - And finally, if the feature is not covered by either of the above, refer to
    [[https://www.tcl.tk/man/tcl8.7/TclCmd/contents.htm][Tcl]]/[[https://www.tcl.tk/man/tcl8.7/TkCmd/contents.htm][Tk]] documentation for the official specification, and make educated guess
    on what Python method / arguments to pass.

* General Design
For my simple application, I conceptually divided the components into three:
  state, widgets, and event handlers (AKA actions). These correspond roughly to
  the model, view and controller in the traditional MVC framework.

** State
I initialize the state in the ~__init__()~ method of my ~App~ class:
  #+BEGIN_SRC python
    class App:
  
        def __init__(self, master, menu=None):
  
            ...
  
            # Data
            self.chrome_driver_path = tk.StringVar()
            self.download_path = tk.StringVar()
            self.forms = OrderedDict()
            self.form_name = tk.StringVar()
            self.form_id = tk.StringVar()
            self.form_secret_key = tk.StringVar()
            self.email = tk.StringVar()
            self.one_time_password = tk.StringVar()

            ...
  #+END_SRC
  Notice the use of ~tk.StringVar()~ to create the variables; this is necessary
  for two-way communication with the widgets that will be displaying the data,
  or accepting input for the data.

** Widgets
I created a mini-dsl using ~namedtuple~ and a simple loop, so that
  the widget-related code may be written in a more declarative-like way.

  The ~namedtuple~ definition is as follows:
  #+BEGIN_SRC python
  Widget = namedtuple('Widget', 'name type options geometry_manager geometry_options',
                      defaults=[{}, 'pack', {}])
  #+END_SRC

  The fields of the namedtuple has the following meaning:
  | Field Name         | Meaning                                                          |
  |--------------------+------------------------------------------------------------------|
  | ~name~             | name of the widget, serving as identifier                        |
  | ~type~             | type of the widget, e.g., ttk.Entry for a usual text input       |
  | ~options~          | arguments for the widget constructor, e.g., ~ttk.Entry(options)~ |
  | ~geometry_manager~ | one of the three geometry managers in Tk: place, pack or grid    |
  | ~geometry_options~ | arugments for the geometry manager method, e.g. ~.pack(options)~ |

  With the above ~namedtuple~ defined, I'm able to declaratively define all the
  widgets, and initialize them using the following loop:

  #+BEGIN_SRC python
    WIDGETS = [
            Widget('frame_config', ttk.LabelFrame,
                   {'text': 'Step 0: Configuration'}, 'grid',
                   {'column': 0, 'row': 0, 'padx': 10, 'pady': 10}),
            ... # More widgets here
            ]

    # Actual loop to instantiate and position the widgets
    for name, widget_type, options, geometry_manager, geometry_options in WIDGETS:

        parent = options.pop('parent', None)
        parent_widget = self.widgets.get(parent, master)
        w = widget_type(parent_widget, **options)
        getattr(w, geometry_manager)(**geometry_options)
        self.widgets[name] = w
  #+END_SRC

** Progress So Far
With the mini-dsl in place, it is sufficiently simple to declare the layout to
  get something like this:

[[/img/post-a-python-gui-app-screenshot.png]]

In the next part, I'll cover how I added the event handlers (including a brief
  foray into asynchronous GUI programming), and hopefully the releasing and
  packaging of the application.

* Conclusion
Don't be afraid to design your own mini-language if it makes your life simpler,
  especially for a side project.
